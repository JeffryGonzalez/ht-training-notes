## DevOps for Services Developers

This two-day course will prepare developers to deliver code in a DevOps organization.

### Prerequisites

This is developer training. We assume developers are proficient with C# and Visual Studio. Developers should take course [DevOps Essiential](#devops-essentials) before taking this course.

### Objectives

The objective of this course is for experienced developers to "upsize" their skills to successfully recognize and implement software coding and development patterns for a successful DevOps project.

#### Micro-Patterns For CI/CD

> Learn to understand and recognize the low-level decisions and approaches in software development and how they empower (or destroy) our ability to put code into production continually. We will explore _hypothesis driven development_ as a way to prove the necessity of a new feature before investing heavily in its development. We will begin to change our mindset as developers from "What can we add in our next sprint to move things forward" to "what can we add today to make sure we are building the _right thing_?"

#### Source Code Control in DevOps

> As developers, we have used source control of some form for years. Our brothers and sisters on the "operations" side are the ones that finally started to take the promise of source code control as the "Single Source of Truth" seriously. We have a lot to learn from them. In this section developers will learn the importance of using source code control (Git) to fully describe the current _desired_ state of our application, from the functionality of our code (build), the tests that ensure our understanding of the requirements, as well as the configuration and resources our application needs to run.

#### Networking Essentials for DevOps Developers

> As we, as developers, share the responsibility for how our applications run in production, we need to increase our knowledge of some _basic_ networking. We will discuss the major protocols (UDP, TCP), addressing, naming (DNS), discovery, and the restrictions of expecting reliable networking.

#### Cloud Native Development

> This section will enable developers to describe formally the requirements for their application by defining the containers in which their applications will run. Developers will learn to carefully construct `Dockerfile`s that build quickly and deploy instantly. We will discuss resource limits, base image selection, the necessity of rebuilding containers frequently (even if "nothing has changed"). We will also learn the key steps to creating deployments, services, and other supporting objects for running our containers in an orchestrated environment (Kubernetes/OpenShift).

#### Configuration Management

> In a DevOps environment we ship the configuration of our applications as part of our deliverables. We will look at how we use a variety of formats (JSON, YAML, etc.) to describe that configuration, and how configuration can be adjusted and "injected" into running services in Kubernetes/OpenShift.

#### Feature Flags and Branch by Abstraction

> A key question that arises when you finally start getting into the "flow" of DevOps is how to not get blocked when your team isn't the team that will (always) decide when your code is an "official release" that will go in front of users. We will be called daily to "work in the future", adding features and changing behaviour of our application through _configuration_. We will explore various techniques for enabling this kind of work, while still allowing us to deploy and test software continually, even though it might not be seen by a user in the current relase.

### Expected Outcome of this Training

At the conclusion of the DevOps for Developers course, developers will be able to:

- Know low-level coding practices that contribute to DevOps success.
- Effectively use source code control as a communication device to give greater insight into your product.
- Make good networking choices when configuring and specifying your applications for production.
- Chose technolgies and practices that give the greatest flexibility in deployment in a Cloud Native environment.
- Implment a configuration management strategy that eliminates hidden differences between applications running in different environments.
- Use feature flags and other branch-by-abstraction techniques to continually add value to applications and services, even before release.
